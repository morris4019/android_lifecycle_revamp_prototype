# Android Granular Lifecycle #This is a quick implementation to show the direction the standard Android lifecycles could be modified, using inheritance, to support more advanced technologies/patterns/libraries (not simply Android Recommended Practices) running side-by-side with little to no downstream issues.###Example Problem (Use Case)###Abstraction and inheritance are all well and good-but some of the technologies and patterns commonly used don't always play well together. A specific example would be multiple *Activity* classes extending a base class. If not using Android Data Binding (and sometimes even still) typically developers choose some way of achieving view binding. A common choice is ButterKnife-it's quick and easy to get setup and going. ButterKnife uses annotations to bind fields and build a list of required ids that it needs to create bindings for. Note-this happens during annotation processing. Every time a call to `ButterKnife.bind(this)` is made this list is verified and bound to the fields.In an inheritance chain it may be necessary to have common views live in a base-which would eventually need to be bound. It doesn't always make sense to have to call `ButterKnife.bind(this)` inside every root-child activity. Nevertheless we need to ensure that any classes in the inheritance chain, that have `@Bind`/`@BindView` annotations, are either **also** annotated as `@Nullable`/`@Optional` *(and, of course, should always have defensive null code-unless it's kotlin that is...)* or only called *once*-after all layout amendments have been made.###Proposed Solution Design###*Disclaimer: This is by no means a singular answer-just trying to try and show where my head is going.*In general it probably harder to assume that every new developer, or current developers, on a project **must** remember to call `ButterKnife.bind()` in their activity-i'm all for the abstraction! If we can count on this as a constraint then a perfectly acceptable solution would be to, as elegantly as possible, ensure that `ButterKnife.bind()` is only called once.This example showcases one way we could make the onCreate process a bit more granular and, provided the methods are used appropriately, only execute the bind once. Code is self documented, but here is a quick rundown on the key-classes:- **GranularLifecycle.java** - is the interface which defines our added/granular lifecycle methods.- **BaseButterKnifeBoundActivity.java** - is the first tier of the abstraction. Defines the internal execution flow of the added/granular methods. Provides internal processing methods (if necessary). Added a "verbose" logging functionality to showcase in logcat.- **BaseActivity.java** - This is the app-specific side of things. Extend/implement the app common functionality using the added/granular methods.
###Sample###The sample uses 2 activities with both un/common ui elements/logic, as well as BaseActivity, itself, binding and using un/common views, using the above inheritance structure, binding once.